package edu.sdsc.inca;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.KeyboardFocusManager;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Arrays;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.DefaultListModel;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JScrollPane;
import javax.swing.ListCellRenderer;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

/**
 * A convenience class that combines a scrollable JList and its Model.  It
 * allows listening for focus and list selection events via an ActionListener
 * instead of a Focus/ListSelectionListener.  Action commands generated by an
 * IncatList are:
 *   DoubleClick -- user has double-clicked a selection
 *   FocusLost -- the list has lost keyboard focus
 *   FocusGained -- the list has gained keyboard focus
 *   SingleClick -- user has single-clicked a selection
 *   XXX -- user has clicked the associated button labeled with XXX
 * Class instances prefix each of these commands with a client-supplied prefix
 * to allow listeners to distinguish between actions from multiple IncatLists.
 */
public class IncatList extends Box
  implements FocusListener, ListSelectionListener, MouseListener {

  protected static String lastFind = null;

  protected String commandPrefix;
  protected JList list;
  protected ActionListener listener;
  protected DefaultListModel model;

  /**
   * Constructs an IncatList.
   *
   * @param title title for this list, optional
   * @param prefix text prepended to action commands generated by this list,
   *               optional
   * @param buttons comma-delimited list of labels for buttons to attach to
   *                this list, optional
   * @param listener listener to notify when the user acts on the list/buttons,
   *                 optional
   */
  public IncatList(String title,
                   String prefix,
                   String buttons,
                   ActionListener listener) {
    super(BoxLayout.Y_AXIS);
    this.model = new DefaultListModel();
    this.list = new JList(this.model);
    this.list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
    this.list.addFocusListener(this);
    this.list.addListSelectionListener(this);
    this.list.addMouseListener(this);
    this.setCommandPrefix(prefix);
    this.setActionListener(listener);
    JScrollPane scroller = new JScrollPane(this.list);
    scroller.setPreferredSize(new Dimension(250, 200));
    this.add(scroller);
    if(title != null) {
      this.add(IncatComponents.BoxFactory(new JComponent[] {
        new JLabel(title, JLabel.CENTER)
      }, true));
    }
    if(buttons != null) {
      String[] labels = buttons.split(",");
      JComponent[] jbuttons = new JComponent[labels.length];
      for(int i = 0; i < labels.length; i++) {
        String label = labels[i];
        jbuttons[i] =
          IncatComponents.JButtonFactory(label, prefix + label, listener);
      }
      this.add(IncatComponents.BoxFactory(jbuttons, true));
    }
  }

  /**
   * Appends an element to the end of the list.
   *
   * @param o the element to append
   */
  public void addElement(Object o) {
    this.model.addElement(o);
  }

  /**
   * Returns the index of the element that matches a specific string; returns
   * -1 if no element matches.
   *
   * @param s the string to match
   * @return the index of the matching element; -1 if none
   */
  public int findMatchingElement(String s) {
    for(int i = 0; i < this.getLength(); i++) {
      if(this.getElementAt(i).toString().equals(s)) {
        return i;
      }
    }
    return -1;
  }

  /**
   * Returns the listener notified when the user selects an element.
   *
   * @return the listener
   */
  public ActionListener getActionListener() {
    return this.listener;
  }

  /**
   * Returns the string prepended to action commands generated by this list.
   *
   * @return the command prefix
   */
  public String getCommandPrefix() {
    return this.commandPrefix;
  }

  /**
   * Return the element at a specified index.
   *
   * @param index the requested index
   * @return the element at index, null if none
   */
  public Object getElementAt(int index) {
    return index >= 0 && index < this.getLength() ?
           this.model.getElementAt(index) : null;
  }

  /**
   * Returns the length of the list.  NOTE: can't name this method either
   * size() or getSize(), since Component declares these to return Dimension.
   *
   * @return the number of elements in the list
   */
  public int getLength() {
    return this.model.getSize();
  }

  /**
   * Returns the first selected element; returns null if none.
   *
   * @return the first selected element; null if none
   */
  public Object getSelectedElement() {
    int index = this.getSelectedIndex();
    return index < 0 ? null : this.getElementAt(index);
  }

  /**
   * Returns the first selected index; returns -1 if none.
   *
   * @return the first selected index; -1 if none
   */
  public int getSelectedIndex() {
    // NOTE: JList.getSelectedIndex() is supposed to return -1 if no value
    // is selected, but it seems to throw an exception instead
    try {
      return this.list.getSelectedIndex();
    } catch(ArrayIndexOutOfBoundsException e) {
      return -1;
    }
  }

  /**
   * Adds an element at a specified position in the list.
   *
   * @param o the object to insert
   * @param index the position to insert the object
   */
  public void insertElementAt(Object o, int index) {
    this.model.insertElementAt(o, index);
  }

  /**
   * Removes all elements from the list.
   */
  public void removeAllElements() {
    this.model.removeAllElements();
  }

  /**
   * Removes the element, if any, at a specified index.
   *
   * @param index the requested index
   */
  public void removeElementAt(int index) {
    if(index >= 0 && index < this.getLength()) {
      this.model.removeElementAt(index);
      if(index < this.getLength()) {
        this.setSelectedIndex(index);
      } else if(this.getLength() > 0) {
        this.setSelectedIndex(this.getLength() - 1);
      }
    }
  }

  /**
   * Selects the element that matches a specified string.
   *
   * @param s the value to match
   * @return true if the specified string was found/selected, otherwise false
   */
  public boolean selectMatchingElement(String s) {
    int index = this.findMatchingElement(s);
    if(index < 0) {
      return false;
    }
    this.setSelectedIndex(index);
    return true;
  }

  /**
   * Sets the listener notified when the user selects an element.
   *
   * @param listener the listener
   */
  public void setActionListener(ActionListener listener) {
    this.listener = listener;
  }

  /**
   * Sets the class that determines the presentation of list elements.
   *
   * @param the cell renderer for this list
   */
  public void setCellRenderer(ListCellRenderer lcr) {
    this.list.setCellRenderer(lcr);
  }

  /**
   * Sets the string prepended to action commands generated by this list.
   *
   * @param prefix the command prefix
   */
  public void setCommandPrefix(String prefix) {
    this.commandPrefix = prefix;
  }

  /**
   * Replaces an element at a specified position in the list.
   *
   * @param o the object to insert
   * @param index the position to replace with the object
   */
  public void setElementAt(Object o, int index) {
    this.model.setElementAt(o, index);
  }

  /**
   * Removes all existing elements from the list and adds a specified set.
   *
   * @param elements the set of elements to add
   */
  public void setElements(Object[] elements) {
    this.removeAllElements();
    for(int i = 0; i < elements.length; i++) {
      this.addElement(elements[i]);
    }
  }

  /**
   * Selects a specified element.
   *
   * @param o the element to select
   * @return true if the specified element is found/selected, false otherwise
   */
  public boolean setSelectedElement(Object o) {
    for(int i = 0; i < this.getLength(); i++) {
      if(this.getElementAt(i) == o) {
        this.setSelectedIndex(i);
        return true;
      }
    }
    return false;
  }

  /**
   * Selects the element, if any, at the specified index.
   *
   * @param index the requested index
   */
  public void setSelectedIndex(int index) {
    if(index >= 0 && index < this.getLength()) {
      this.list.setSelectedIndex(index);
      this.list.ensureIndexIsVisible(index);
    }
  }

  /**
   * Rearranges the list to display the elements in increasing alpha order.
   */
  public void sort() {
    // Temporarily halt reporting of selection events
    ActionListener l = this.listener;
    this.listener = null;
    Object selected = this.getSelectedElement();
    Object[] elements = this.toArray();
    String[] elementStrings = new String[elements.length];
    for(int i = 0; i < elements.length; i++) {
      elementStrings[i] = elements[i].toString() + '-' + i;
    }
    Arrays.sort(elementStrings);
    this.removeAllElements();
    for(int i = 0; i < elementStrings.length; i++) {
      String s = elementStrings[i];
      this.addElement
        (elements[Integer.parseInt(s.substring(s.lastIndexOf('-') + 1))]);
    }
    if(selected != null) {
      this.setSelectedElement(selected);
    }
    // Resume reporting selection events
    this.listener = l;
  }

  /**
   * Returns an array of the elements in this list.
   *
   * @return an array of all elements in this list
   */
  public Object[] toArray() {
    return toArray(null);
  }

  /**
   * Returns an array of the element in this list.
   *
   * @param a the array to contain the elements--the length must match the
   *          number of elements in the IncatList, optional
   * @return the array a with the list elements inserted
   */
  public Object[] toArray(Object[] a) {
    if(a == null) {
      a = new Object[this.getLength()];
    }
    for(int i = 0; i < a.length; i++) {
      a[i] = this.model.getElementAt(i);
    }
    return a;
  }

  /**
   * Forwards focus events to this list's listener.
   */
  public void focusGained(FocusEvent e) {
    if(this.listener != null && this.commandPrefix != null) {
      this.listener.actionPerformed(
        new ActionEvent(e.getSource(), ActionEvent.RESERVED_ID_MAX + 1,
                        this.commandPrefix + "FocusGained")
      );
    }
  }

  /**
   * Forwards focus events to this list's listener.
   */
  public void focusLost(FocusEvent e) {
    if(this.listener != null && this.commandPrefix != null) {
      this.listener.actionPerformed(
        new ActionEvent(e.getSource(), ActionEvent.RESERVED_ID_MAX + 1,
                        this.commandPrefix + "FocusLost")
      );
    }
  }

  /**
   * Forwards selection events to the list's listener.
   */
  public void mouseClicked(MouseEvent e) {
    if(this.listener != null &&
       this.commandPrefix != null &&
       e.getClickCount() == 2) {
      this.listener.actionPerformed(
        new ActionEvent(e.getSource(), ActionEvent.RESERVED_ID_MAX + 1,
                        this.commandPrefix + "DoubleClick")
      );
    }
  }

  public void mouseEntered(MouseEvent e) {/* empty */}
  public void mouseExited(MouseEvent e) {/* empty */}
  public void mousePressed(MouseEvent e) {/* empty */}
  public void mouseReleased(MouseEvent e) {/* empty */}

  /**
   * Forwards list selections to the list's listener.
   */
  public void valueChanged(ListSelectionEvent e) {
    if(!e.getValueIsAdjusting() &&
       this.listener != null &&
       this.commandPrefix != null) {
      this.listener.actionPerformed(
        new ActionEvent(e.getSource(), ActionEvent.RESERVED_ID_MAX + 1,
                        this.commandPrefix + "SingleClick")
      );
    }
  }

  /**
   * Searches for an element in a list.
   *
   * @param prompt ask the user to enter a search text; if false, reuse the
   *               most recent text
   */
  protected static void findListElement(boolean prompt) {
    java.awt.Component focused =
      KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner();
    while(focused != null && !(focused instanceof IncatList)) {
      focused = focused.getParent();
    }
    if(focused == null) {
      return;
    }
    String s = prompt ?
               JOptionPane.showInputDialog("Find:", IncatList.lastFind) :
               IncatList.lastFind;
    if(s == null) {
      return;
    }
    IncatList.lastFind = s;
    IncatList l = (IncatList)focused;
    int current = l.getSelectedIndex();
    int i = current;
    int max = l.getLength() - 1;
    do {
      i = i < max ? i + 1 : 0;
      if(l.getElementAt(i).toString().indexOf(s) >= 0) {
        // NOTE: setting the selected index fires the list selection listener,
        // so we'll have a chance to update related lists
        l.setSelectedIndex(i);
        return;
      }
    } while(i != current);
  }

  /**
   * Creates and returns a JLabel to represent a list element.
   *
   * @param list the list that contains the element
   * @param element the element to represent
   * @param isSelected indicates whether the element is currently selected
   * @return a JLabel representation of the element in the list
   */
  public static JLabel listElementLabel
    (JList list, Object element, boolean isSelected) {
    JLabel result = new JLabel();
    result.setText(element.toString());
    result.setBackground
      (isSelected ? list.getSelectionBackground() : list.getBackground());
    result.setForeground(Color.BLACK);
    result.setEnabled(list.isEnabled());
    result.setFont(list.getFont());
    result.setOpaque(true);
    return result;
  }

}
