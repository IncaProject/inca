package edu.sdsc.inca.util;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.HashSet;
import java.util.Iterator;

/**
 * A pattern (regular expression) that can return the set of strings it matches.
 * See the JavaDoc for java.util.regex.Pattern for details of regexp syntax.
 */
public class ExpandablePattern {

  public static final int MAX_EXPANSION = 300;
  protected static final Exception EXPANSION_SET_TOO_BIG =
    new Exception("Expansion set too large");

  private String regexp;

  /**
   * Constructs a new ExpandablePattern that uses a specified regular
   * expression.
   *
   * @param pattern the regular expression to use in matches
   */
  public ExpandablePattern(String pattern) {
    this(pattern, false);
  }

  /**
   * Constructs a new ExpandablePattern that uses a specified regular expresion
   * or Glob-style pattern.
   *
   * @param pattern the pattern to use in matches
   * @param glob if true, the specified pattern is Glob-style (* and ?
   * wildcards; . not special); otherwise, it's a regular expression.
   */
  public ExpandablePattern(String pattern, boolean glob) {
    if(glob) {
      pattern = pattern.replaceAll("\\.", "\\\\.").replaceAll("\\*", ".*").
                        replaceAll("\\?", ".");
    }
    this.regexp = pattern;
  }

  /**
   * Returns the set of strings that a specified regular expression matches.
   *
   * @return a HashSet containing the set of matching strings
   * @throws Exception if the set is too large
   */
  public HashSet expand() throws Exception {
    return ExpandablePattern.expand(this.regexp);
  }

  /**
   * Returns true iff this pattern matches s.
   *
   * @param s the string to test
   * @return true iff this pattern matches the given string
   */
  public boolean matches(String s) {
    return s.matches(this.regexp);
  }

  /**
   * Returns a regular expression that matches the same strings as this pattern.
   *
   * @return a regular expression equivalent to this pattern.
   */
  public String toString() {
    return this.regexp;
  }

  /**
   * Returns the set of strings that a specified regular expression matches.
   *
   * @param regexp the regular expression to expand.
   * @return a HashSet containing the set of matching strings
   * @throws Exception if the set is too large
   */
  public static HashSet expand(String regexp) throws Exception {
    return ExpandablePattern.expand(regexp, null);
  }

  /**
   * Returns the set of strings that a specified regular expression matches.
   *
   * @param regexp the regular expression to expand.
   * @param prepend a set of strings to prepend to each string generated by
   *                the regular expression
   * @return a HashSet containing the set of matching strings
   * @throws Exception if the set is too large
   */
  public static HashSet expand(String regexp, HashSet prepend)
    throws Exception {

    char c;
    int cursor = 0;
    int len = regexp.length();
    HashSet result = new HashSet();

    // Find the end of the first element w/in regexp and expand it.  An element
    // is either '.', a character set (surrounded by brackets), a capturing
    // group (surrounded by parens), one of the boundary markers '^' and '$',
    // a plain character, or an escaped character (preceeded by backslash).
    if(cursor < len) {
      c = regexp.charAt(cursor++);
      if(c == '.') {
        throw EXPANSION_SET_TOO_BIG;
      } else if(c == '[' || c == '(') {
        // Element continues to matching ] or )
        int begin = cursor;
        int nesting = 1;
        char opener = c;
        char closer = opener == '[' ? ']' : ')';
        while(nesting > 0) {
          c = regexp.charAt(cursor++);
          if(c == opener) {
            nesting++;
          } else if(c == closer) {
            nesting--;
          } else if(c == '\\') {
            cursor++;
          }
        }
        String inner = regexp.substring(begin, cursor - 1);
        result = opener == '[' ?
                 ExpandablePattern.expandCharSet(inner) :
                 ExpandablePattern.expand(inner);
      } else if(c == '\\') {
        char d = regexp.charAt(cursor);
        int escapeSpan;
        if(d == 'c') {
          escapeSpan = 2;
        } else if(d == '0') {
          escapeSpan =
            regexp.substring(cursor).matches("0[0-3][0-7][0-7].*") ? 4 :
            regexp.substring(cursor).matches("0[0-7][0-7].*") ? 3 : 2;
        } else if(d == 'p') {
          escapeSpan = regexp.indexOf('}', cursor) - cursor;
        } else if(d == 'u') {
          escapeSpan = 5;
        } else if(d == 'x') {
          escapeSpan = 3;
        } else {
          escapeSpan = 1;
        }
        result = ExpandablePattern.expandCharSet
          (regexp.substring(cursor - 1, cursor + escapeSpan));
        cursor += escapeSpan;
      } else if(c == '^' || c == '$') {
        // TODO?
        result.add("");
      } else {
        result.add(c + "");
      }
    }

    // Now handle postfix quantifiers: '+', '*', '?', and ranges (braces with
    // low and optional high bounds).
    if(cursor < len) {
      c = regexp.charAt(cursor++);
      if(c == '+' || c == '*') {
        throw EXPANSION_SET_TOO_BIG;
      } else if(c == '?') {
        result.add("");
      } else if(c == '{') {
        String shortPat = regexp.substring(0, cursor - 1);
        int low = 0;
        while((c = regexp.charAt(cursor++)) >= '0' && c <= '9') {
          low = low * 10 + c - '0';
        }
        int high = low;
        if(c == ',') {
          c = regexp.charAt(cursor);
          if(c == '}') {
            throw EXPANSION_SET_TOO_BIG;
          }
          high = 0;
          while((c = regexp.charAt(cursor++)) >= '0' && c <= '9') {
            high = high * 10 + c - '0';
          }
        }
        if(high * result.size() > MAX_EXPANSION) {
          throw EXPANSION_SET_TOO_BIG;
        }
        if(high < low) {
          result = new HashSet();
        } else {
          String longPat = "";
          for(int i = 0; i < low; i++) {
            longPat += shortPat;
          }
          for(int i = low + 1; i <= high; i++) {
            longPat += shortPat + "?";
          }
          result = ExpandablePattern.expand(longPat, null);
        }
      } else {
        cursor--;
      }
      if(cursor < len &&
         (regexp.charAt(cursor) == '?' || regexp.charAt(cursor) == '+')) {
        // Reluctant, possessive quantifiers
        cursor++;
      }
    }

    // Combine each item from the expansion of this element with each of the
    // elements that preceded it (the prepend parameter).
    if(prepend == null || prepend.size() == 0) {
      // empty
    } else if(result.size() == 0) {
      result = prepend;
    } else if(prepend.size() * result.size() > MAX_EXPANSION) {
      throw EXPANSION_SET_TOO_BIG;
    } else {
      HashSet merged = new HashSet();
      for(Iterator i = prepend.iterator(); i.hasNext(); ) {
        String prefix = (String)i.next();
        for(Iterator j = result.iterator(); j.hasNext(); ) {
          merged.add(prefix + (String)j.next());
        }
      }
      result = merged;
    }

    // Finally, recurse to merge the set we've developed here with the set of
    // strings that match any remaining portion of regexp.
    if(cursor == len) {
      // empty
    } else if(regexp.charAt(cursor) == '|') {
      result.addAll(ExpandablePattern.expand(regexp.substring(cursor+1), null));
    } else {
      result = ExpandablePattern.expand(regexp.substring(cursor), result);
    }

    return result;

  }

  /**
   * Returns the set of strings that a specified character set matches.
   *
   * @param charSet the character set to expand, not including enclosing []
   * @return a HashSet containing the set of matching strings
   */
  protected static HashSet expandCharSet(String charSet) throws Exception {

    int len = charSet.length();
    int cursor = len > 0 && charSet.charAt(0) == '^' ? 1 : 0;
    char rangeLow = (char)-1;
    HashSet result = new HashSet();

    while(cursor < len) {
      // TODO union []/intersection &&[]
      char c = charSet.charAt(cursor++);
      // Check for predefined character class/boundary matcher
      if(c == '\\' && "AbBdDGpsSwWzZ".indexOf(charSet.charAt(cursor)) >= 0) {
        c = charSet.charAt(cursor++);
        if(c == 'A') {
          // empty? beginning of input
        } else if(c == 'b' || c == 'B') {
          // empty? word boundary
        } else if(c == 'd') {
          result.addAll(ExpandablePattern.expandCharSet("0-9"));
        } else if(c == 'D') {
          result.addAll(ExpandablePattern.expandCharSet("^0-9"));
        } else if(c == 'G') {
          // empty? end of previous match
        } else if(c == 'p') {
          // TODO posix
        } else if(c == 's') {
          result.addAll(ExpandablePattern.expandCharSet(" \\t\\n\\x0B\\f\\r"));
        } else if(c == 'S') {
          result.addAll(ExpandablePattern.expandCharSet("^ \\t\\n\\x0B\\f\\r"));
        } else if(c == 'w') {
          result.addAll(ExpandablePattern.expandCharSet("a-zA-Z_0-9"));
        } else if(c == 'W') {
          result.addAll(ExpandablePattern.expandCharSet("^a-zA-Z_0-9"));
        } else if(c == 'z' || c == 'Z') {
          // empty? end of input
        }
      } else {
        // Check for character escape, including all the numeric varieties
        if(c == '\\') {
          c = charSet.charAt(cursor++);
          if(c == '0' || c == 'u' || c == 'x') {
            int base = c == '0' ? 8 : 16;
            int value = 0;
            int maxDigits = c == 'u' ? 4 : c == 'x' ? 2 :
                            charSet.charAt(cursor) <= '3' ? 3 : 2;
            String digits = "01234567" + (base == 8 ? "" : "89abcdefABCDEF");
            for(int i = 0;
                i <= maxDigits && cursor < len &&
                digits.indexOf(charSet.charAt(cursor)) >= 0;
                i++) {
              int digit = (c = charSet.charAt(cursor++)) - '0';
              if(c >= 'A' && c <= 'F') {
                digit = c - 'A' + 10;
              } else if(c >= 'a' && c <= 'f') {
                digit = c - 'a' + 10;
              }
              value = value * base + digit;
            }
            c = (char)value;
          } else if(c == 'a') {
            c = '\007';
          } else if(c == 'c') {
            c = (char)(charSet.charAt(cursor++) & 0x1f);
          } else if(c == 'e') {
            c = '\033';
          } else if(c == 'f') {
            c = '\014';
          } else if(c == 'n') {
            c = '\012';
          } else if(c == 'r') {
            c = '\015';
          } else if(c == 't') {
            c = '\011';
          }
        }
        // If we have the high bound of a character range (e.g. a-z), add all
        // characters in the range.  Otherwise, check to see if the next char
        // is a dash, indicating we've just processed the low bound.
        if(rangeLow != (char)-1) {
          while(rangeLow <= c) {
            result.add(rangeLow++ + "");
          }
          rangeLow = (char)-1;
        } else if(cursor < len && charSet.charAt(cursor) == '-') {
          cursor++;
          rangeLow = c;
        } else {
          result.add(c + "");
        }
      }
    }

    if(len > 0 && charSet.charAt(0) == '^') {
      // negated sets are huge in the unicode world
      throw EXPANSION_SET_TOO_BIG;
    }
    return result;

  }

  /**
   * Interactive test program for Expandable pattern.  Repeatedly accepts a
   * pattern from the user and prints the expansion.
   */
  public static void main(String[] args) {
    BufferedReader keyboard =
      new BufferedReader(new InputStreamReader(System.in));
    while(true) {
      System.out.print("> ");
      try {
        String pat = keyboard.readLine();
        if(pat == null) {
          break;
        }
        HashSet expanded = new ExpandablePattern(pat).expand();
        for(Iterator i = expanded.iterator(); i.hasNext(); ) {
          System.out.println("'" + i.next() + "'");
        }
      } catch(Exception e) {
        //System.out.println("too big");
        e.printStackTrace();
      }
    }
  }

}
